{"ColumnNames":["Column Name 00","Column Name 01","Column Name 02","Column Name 03","Column Name 04","Column Name 05","Column Name 06","Column Name 07","Column Name 08","Column Name 09","Column Name 10","Column Name 11","Column Name 12","Column Name 13","Column Name 14","Column Name 15","Column Name 16","Column Name 17","Column Name 18","Column Name 19"],"Modules":{"Microsoft.Graph.Authentication":{"Location":"All Users","Name":"Microsoft.Graph.Authentication","Version":"1.9.5"},"Az.Accounts":{"Location":"All Users","Name":"Az.Accounts","Version":"2.7.6"},"MSAL.PS":{"Location":"All Users","Name":"MSAL.PS","Version":"4.37.0.0"}},"Functions":{"Get-MyADObject":{"Name":"Get-MyADObject","ScriptBlock":"\r\n  \u003c#\r\n    .SYNOPSIS\r\n      Searches Active Directory and returns an AD SearchResultCollection.\r\n    .DESCRIPTION\r\n      Performs a search in Active Directory using the specified LDAP filter and returns a SearchResultCollection. \r\n      Supports specifying search root, server, credentials, properties to load, sorting, and paging options.\r\n    .PARAMETER LDAPFilter\r\n      The LDAP filter string to use for the search. Defaults to (objectClass=*).\r\n    .PARAMETER PageSize\r\n      The number of objects to return per page. Default is 1000.\r\n    .PARAMETER SizeLimit\r\n      The maximum number of objects to return. Default is 1000.\r\n    .PARAMETER SearchRoot\r\n      The LDAP path to start the search from. Defaults to the current domain root.\r\n    .PARAMETER ServerName\r\n      The name of the domain controller or server to query. If not specified, uses the default.\r\n    .PARAMETER SearchScope\r\n      The scope of the search. Valid values are Base, OneLevel, or Subtree. Default is Subtree.\r\n    .PARAMETER Sort\r\n      The direction to sort the results. Valid values are Ascending or Descending. Default is Ascending.\r\n    .PARAMETER SortProperty\r\n      The property name to sort the results by.\r\n    .PARAMETER PropertiesToLoad\r\n      An array of property names to load for each result.\r\n    .PARAMETER Credential\r\n      The credentials to use when searching Active Directory.\r\n    .EXAMPLE\r\n      Get-MyADObject -LDAPFilter \"(objectClass=user)\" -SearchRoot \"OU=Users,DC=domain,DC=com\"\r\n      Searches for all user objects in the specified OU.\r\n    .EXAMPLE\r\n      Get-MyADObject -ServerName \"dc01.domain.com\" -PropertiesToLoad \"samaccountname\",\"mail\"\r\n      Searches using a specific domain controller and returns only the samaccountname and mail properties.\r\n    .NOTES\r\n      Original Function By Ken Sweet\r\n  #\u003e\r\n  [CmdletBinding(DefaultParameterSetName = \"Default\")]\r\n  param (\r\n    [String]$LDAPFilter = \"(objectClass=*)\",\r\n    [Long]$PageSize = 1000,\r\n    [Long]$SizeLimit = 1000,\r\n    [String]$SearchRoot = \"LDAP://$($([ADSI]\u0027\u0027).distinguishedName)\",\r\n    [String]$ServerName,\r\n    [ValidateSet(\"Base\", \"OneLevel\", \"Subtree\")]\r\n    [System.DirectoryServices.SearchScope]$SearchScope = \"SubTree\",\r\n    [ValidateSet(\"Ascending\", \"Descending\")]\r\n    [System.DirectoryServices.SortDirection]$Sort = \"Ascending\",\r\n    [String]$SortProperty,\r\n    [String[]]$PropertiesToLoad,\r\n    [PSCredential]$Credential\r\n  )\r\n  Write-Verbose -Message \"Enter Function $($MyInvocation.MyCommand)\"\r\n\r\n  $MySearcher = [System.DirectoryServices.DirectorySearcher]::New($LDAPFilter, $PropertiesToLoad, $SearchScope)\r\n\r\n  $MySearcher.PageSize = $PageSize\r\n  $MySearcher.SizeLimit = $SizeLimit\r\n\r\n  $TempSearchRoot = $SearchRoot.ToUpper()\r\n  switch -regex ($TempSearchRoot)\r\n  {\r\n    \"(?:LDAP|GC)://*\"\r\n    {\r\n      if ($PSBoundParameters.ContainsKey(\"ServerName\"))\r\n      {\r\n        $MySearchRoot = $TempSearchRoot -replace \"(?\u003cLG\u003e(?:LDAP|GC)://)(?:[\\w\\d\\.-]+/)?(?\u003cDN\u003e.+)\", \"`${LG}$($ServerName)/`${DN}\"\r\n      }\r\n      else\r\n      {\r\n        $MySearchRoot = $TempSearchRoot\r\n      }\r\n      break\r\n    }\r\n    default\r\n    {\r\n      if ($PSBoundParameters.ContainsKey(\"ServerName\"))\r\n      {\r\n        $MySearchRoot = \"LDAP://$($ServerName)/$($TempSearchRoot)\"\r\n      }\r\n      else\r\n      {\r\n        $MySearchRoot = \"LDAP://$($TempSearchRoot)\"\r\n      }\r\n      break\r\n    }\r\n  }\r\n\r\n  if ($PSBoundParameters.ContainsKey(\"Credential\"))\r\n  {\r\n    $MySearcher.SearchRoot = [System.DirectoryServices.DirectoryEntry]::New($MySearchRoot, ($Credential.UserName), (($Credential.GetNetworkCredential()).Password))\r\n  }\r\n  else\r\n  {\r\n    $MySearcher.SearchRoot = [System.DirectoryServices.DirectoryEntry]::New($MySearchRoot)\r\n  }\r\n\r\n  if ($PSBoundParameters.ContainsKey(\"SortProperty\"))\r\n  {\r\n    $MySearcher.Sort.PropertyName = $SortProperty\r\n    $MySearcher.Sort.Direction = $Sort\r\n  }\r\n\r\n  $MySearcher.FindAll()\r\n\r\n  $MySearcher.Dispose()\r\n  $MySearcher = $Null\r\n  $MySearchRoot = $Null\r\n  $TempSearchRoot = $Null\r\n\r\n  Write-Verbose -Message \"Exit Function $($MyInvocation.MyCommand)\"\r\n"},"Get-MyADForest":{"Name":"Get-MyADForest","ScriptBlock":"\r\n  \u003c#\r\n    .SYNOPSIS\r\n      Gets information about an Active Directory Forest.\r\n    .DESCRIPTION\r\n      Retrieves the Active Directory Forest object either for the current forest or for a specified forest name.\r\n    .PARAMETER Name\r\n      The name of the Active Directory forest to retrieve. This parameter is mandatory when using the \"Name\" parameter set.\r\n    .PARAMETER Current\r\n      Switch parameter. If specified, retrieves the current Active Directory forest. This parameter is mandatory when using the \"Current\" parameter set.\r\n    .EXAMPLE\r\n      PS C:\\\u003e Get-MyADForest -Current\r\n      Retrieves the current Active Directory forest.\r\n    .EXAMPLE\r\n      PS C:\\\u003e Get-MyADForest -Name \"contoso.com\"\r\n      Retrieves the Active Directory forest with the name \"contoso.com\".\r\n    .NOTES\r\n      Original Function By Ken Sweet\r\n  #\u003e\r\n  [CmdletBinding(DefaultParameterSetName = \"Current\")]\r\n  param (\r\n    [parameter(Mandatory = $True, ParameterSetName = \"Name\")]\r\n    [String]$Name,\r\n    [parameter(Mandatory = $True, ParameterSetName = \"Current\")]\r\n    [Switch]$Current\r\n  )\r\n  Write-Verbose -Message \"Enter Function $($MyInvocation.MyCommand)\"\r\n\r\n  switch ($PSCmdlet.ParameterSetName)\r\n  {\r\n    \"Name\"\r\n    {\r\n      $DirectoryContextType = [System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest\r\n      $DirectoryContext = [System.DirectoryServices.ActiveDirectory.DirectoryContext]::New($DirectoryContextType, $Name)\r\n      [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($DirectoryContext)\r\n      $DirectoryContext = $Null\r\n      $DirectoryContextType = $Null\r\n      break\r\n    }\r\n    \"Current\"\r\n    {\r\n      [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()\r\n      break\r\n    }\r\n  }\r\n\r\n  Write-Verbose -Message \"Exit Function $($MyInvocation.MyCommand)\"\r\n"},"Get-MyWorkstationInfo":{"Name":"Get-MyWorkstationInfo","ScriptBlock":"\r\n  \u003c#\r\n    .SYNOPSIS\r\n      Verify Remote Workstation is the Correct One\r\n    .DESCRIPTION\r\n      Verify Remote Workstation is the Correct One\r\n    .PARAMETER ComputerName\r\n      Name of the Computer to Verify\r\n    .PARAMETER Credential\r\n      Credentials to use when connecting to the Remote Computer\r\n    .PARAMETER Serial\r\n      Return Serial Number\r\n    .PARAMETER Mobile\r\n      Check if System is Desktop / Laptop\r\n    .INPUTS\r\n    .OUTPUTS\r\n    .EXAMPLE\r\n      Get-MyWorkstationInfo -ComputerName \"MyWorkstation\"\r\n    .NOTES\r\n      Original Script By Ken Sweet\r\n    .LINK\r\n  #\u003e\r\n  [CmdletBinding()]\r\n  param (\r\n    [parameter(Mandatory = $False, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]\r\n    [String[]]$ComputerName = [System.Environment]::MachineName,\r\n    [PSCredential]$Credential,\r\n    [Switch]$Serial,\r\n    [Switch]$Mobile\r\n  )\r\n  begin\r\n  {\r\n    Write-Verbose -Message \"Enter Function Get-MyWorkstationInfo\"\r\n\r\n    # Default Common Get-WmiObject Options\r\n    if ($PSBoundParameters.ContainsKey(\"Credential\"))\r\n    {\r\n      $Params = @{\r\n        \"ComputerName\" = $Null\r\n        \"Credential\"   = $Credential\r\n      }\r\n    }\r\n    else\r\n    {\r\n      $Params = @{\r\n        \"ComputerName\" = $Null\r\n      }\r\n    }\r\n  }\r\n  process\r\n  {\r\n    Write-Verbose -Message \"Enter Function Get-MyWorkstationInfo - Process\"\r\n\r\n    foreach ($Computer in $ComputerName)\r\n    {\r\n      # Start Setting Return Values as they are Found\r\n      $VerifyObject = [MyWorkstationInfo]::New($Computer)\r\n\r\n      # Validate ComputerName\r\n      if ($Computer -match \"^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])$\")\r\n      {\r\n        try\r\n        {\r\n          # Get IP Address from DNS, you want to do all remote checks using IP rather than ComputerName.  If you connect to a computer using the wrong name Get-WmiObject will fail and using the IP Address will not\r\n          $IPAddresses = @([System.Net.Dns]::GetHostAddresses($Computer) | Where-Object -FilterScript { $_.AddressFamily -eq [System.Net.Sockets.AddressFamily]::InterNetwork } | Select-Object -ExpandProperty IPAddressToString)\r\n          :FoundMyWork foreach ($IPAddress in $IPAddresses)\r\n          {\r\n            if ([System.Net.NetworkInformation.Ping]::New().Send($IPAddress).Status -eq [System.Net.NetworkInformation.IPStatus]::Success)\r\n            {\r\n              # Set Default Parms\r\n              $Params.ComputerName = $IPAddress\r\n\r\n              # Get ComputerSystem\r\n              [Void]($MyCompData = Get-WmiObject @Params -Class Win32_ComputerSystem)\r\n              $VerifyObject.AddComputerSystem($Computer, $IPAddress, ($MyCompData.Name), ($MyCompData.PartOfDomain), ($MyCompData.Domain), ($MyCompData.Manufacturer), ($MyCompData.Model), ($MyCompData.UserName), ($MyCompData.TotalPhysicalMemory))\r\n              $MyCompData.Dispose()\r\n\r\n              # Verify Remote Computer is the Connect Computer, No need to get any more information\r\n              if ($VerifyObject.Found)\r\n              {\r\n                # Start Secondary Job, Pass IP Address and Credentials to Job Script to make Connection to Remote Computer\r\n                [Void]($MyOSData = Get-WmiObject @Params -Class Win32_OperatingSystem)\r\n                $VerifyObject.AddOperatingSystem(($MyOSData.ProductType), ($MyOSData.Caption), ($MyOSData.CSDVersion), ($MyOSData.BuildNumber), ($MyOSData.Version), ($MyOSData.OSArchitecture), ([System.Management.ManagementDateTimeConverter]::ToDateTime($MyOSData.LocalDateTime)), ([System.Management.ManagementDateTimeConverter]::ToDateTime($MyOSData.InstallDate)), ([System.Management.ManagementDateTimeConverter]::ToDateTime($MyOSData.LastBootUpTime)))\r\n                $MyOSData.Dispose()\r\n\r\n                # Optional SerialNumber Job\r\n                if ($Serial.IsPresent)\r\n                {\r\n                  # Start Optional Job, Pass IP Address and Credentials to Job Script to make Connection to Remote Computer\r\n                  [Void]($MyBIOSData = Get-WmiObject @Params -Class Win32_Bios)\r\n                  $VerifyObject.AddSerialNumber($MyBIOSData.SerialNumber)\r\n                  $MyBIOSData.Dispose()\r\n                }\r\n\r\n                # Optional Mobile / ChassisType Job\r\n                if ($Mobile.IsPresent)\r\n                {\r\n                  # Start Optional Job, Pass IP Address and Credentials to Job Script to make Connection to Remote Computer\r\n                  [Void]($MyChassisData = Get-WmiObject @Params -Class Win32_SystemEnclosure)\r\n                  $VerifyObject.AddIsMobile($MyChassisData.ChassisTypes)\r\n                  $MyChassisData.Dispose()\r\n                }\r\n              }\r\n              else\r\n              {\r\n                $VerifyObject.UpdateStatus(\"Wrong Workstation Name\")\r\n              }\r\n              # Beak out of Loop, Verify was a Success no need to try other IP Address if any\r\n              break FoundMyWork\r\n            }\r\n          }\r\n        }\r\n        catch\r\n        {\r\n          # Workstation Not in DNS\r\n          $VerifyObject.UpdateStatus(\"Workstation Not in DNS\")\r\n        }\r\n      }\r\n      else\r\n      {\r\n        $VerifyObject.UpdateStatus(\"Invalid Computer Name\")\r\n      }\r\n\r\n      # Set End Time and Return Results\r\n      $VerifyObject.SetEndTime()\r\n    }\r\n    Write-Verbose -Message \"Exit Function Get-MyWorkstationInfo - Process\"\r\n  }\r\n  end\r\n  {\r\n    [System.GC]::Collect()\r\n    [System.GC]::WaitForPendingFinalizers()\r\n    Write-Verbose -Message \"Exit Function Get-MyWorkstationInfo\"\r\n  }\r\n"}},"Variables":{"Z":{"Name":"Z","Value":"Z"},"X":{"Name":"X","Value":"X"},"Y":{"Name":"Y","Value":"Y"}},"ThreadCount":8,"ThreadScript":"\u003c#\r\n  .SYNOPSIS\r\n    Sample Runspace Pool Thread Script\r\n  .DESCRIPTION\r\n    Sample Runspace Pool Thread Script\r\n  .PARAMETER ListViewItem\r\n    ListViewItem Passed to the Thread Script\r\n\r\n    This Paramter is Required in your Thread Script\r\n  .EXAMPLE\r\n    Test-Script.ps1 -ListViewItem $ListViewItem\r\n  .NOTES\r\n    Sample Thread Script\r\n#\u003e\r\n[CmdletBinding(DefaultParameterSetName = \"ByValue\")]\r\nParam (\r\n  [parameter(Mandatory = $False, ParameterSetName = \"ByValue\")]\r\n  [System.Windows.Forms.ListViewItem]$ListViewItem\r\n)\r\n\r\n# Set Preference Variables\r\n$ErrorActionPreference = \"Stop\"\r\n$VerbosePreference = \"SilentlyContinue\"\r\n$ProgressPreference = \"SilentlyContinue\"\r\n\r\n# -------------------------\r\n# ListViewItem Status Icons\r\n# -------------------------\r\n# $GoodIcon = Solid Green Circle\r\n# $BadIcon = Solid Red Circle\r\n# $InfoIcon = Solid Blue Circle\r\n# $CheckIcon = Checkmark\r\n# $ErrorIcon = Red X\r\n# $UpIcon = Green up Arrow \r\n# $DownIcon = Red Down Arrow\r\n\r\n# ------------------------------------------------\r\n# Check if Thread was Already Completed and Exit\r\n#\r\n# One Column needs to be the Status the the Thread\r\n#  Status Messages are Customizable\r\n# ------------------------------------------------\r\nIf ($ListViewItem.SubItems[1].Text -eq \"Completed\")\r\n{\r\n  $ListViewItem.ImageKey = $GoodIcon\r\n  Exit\r\n}\r\n\r\n# ----------------------------------------------------\r\n# Check if Threads are Paused and Update Thread Status\r\n#\r\n# You can add Multiple Checks for Pasue if Needed\r\n# ----------------------------------------------------\r\nIf ($SyncedHash.Paused)\r\n{\r\n  # Set Paused Status\r\n  $ListViewItem.SubItems[1].Text = \"Pause\"\r\n  While ($SyncedHash.Paused)\r\n  {\r\n    [System.Threading.Thread]::Sleep(100)\r\n  }\r\n}\r\n\r\n# -----------------------------------------------------\r\n# Check For Termination and Update Thread Status\r\n#\r\n# You can add Multiple Checks for Termination if Needed\r\n# -----------------------------------------------------\r\nIf ($SyncedHash.Terminate)\r\n{\r\n  # Set Terminated Status and Return\r\n  $ListViewItem.SubItems[1].Text = \"Terminated\"\r\n  $ListViewItem.SubItems[2].Text = [DateTime]::Now.ToString(\"g\")\r\n  $ListViewItem.ImageKey = $InfoIcon\r\n  Exit\r\n}\r\n\r\n# Set Proccessing Ststus\r\n$ListViewItem.SubItems[1].Text = \"Processing\"\r\n$ListViewItem.SubItems[2].Text = [DateTime]::Now.ToString(\"g\")\r\n$WasSuccess = $True\r\n\r\n# --------------------------------------------------\r\n# Get Curent List Item\r\n#\r\n# Coulmn 0 Always has the List Item to be Proccessed\r\n# --------------------------------------------------\r\n$CurentItem = $ListViewItem.SubItems[0].Text\r\n\r\n# --------------------------------------------------------------\r\n# Open and wait for Mutex\r\n# \r\n# This is to Pause the Thread Script if Access a Shared Resource\r\n#   and you need toi Limit to 1 Thread at a Time\r\n#\r\n# Using a Mutext is Optional\r\n# --------------------------------------------------------------\r\n$MyMutex = [System.Threading.Mutex]::OpenExisting($Mutex)\r\n[Void]($MyMutex.WaitOne())\r\n\r\n# Set Date / Time when Mutext was Opened\r\n$ListViewItem.SubItems[3].Text = [DateTime]::Now.ToString(\"g\")\r\n\r\n# --------------------------------------------------------------------------------\r\n# The Synced HashTable has an Object Property to share information between Threads\r\n# --------------------------------------------------------------------------------\r\nIf ([String]::IsNullOrEmpty($SyncedHash.Object))\r\n{\r\n  $SyncedHash.Object = \"First\"\r\n}\r\n$ListViewItem.SubItems[4].Text = $SyncedHash.Object\r\n$SyncedHash.Object = $CurentItem\r\n\r\n# Release Mutex\r\n$MyMutex.ReleaseMutex()\r\n\r\n# Random Number Generator\r\n$Random = [System.Random]::New()\r\n\r\n# ---------------------------------------------------------\r\n# Gernate a Fake Error\r\n#\r\n# Make sure to use Error Catching to make sure thread exits\r\n# ---------------------------------------------------------\r\nTry\r\n{\r\n  Switch ($Random.Next(0, 3))\r\n  {\r\n    \"0\"\r\n    {\r\n      Throw \"This is a Fake Error!\"\r\n      Break\r\n    }\r\n    \"1\"\r\n    {\r\n      Throw \"Simulated Error!\"\r\n      Break\r\n    }\r\n    \"2\"\r\n    {\r\n      Throw \"Someing Failed!\"\r\n      Break\r\n    }\r\n    \"3\"\r\n    {\r\n      Throw \"Unknown Error!\"\r\n      Break\r\n    }\r\n  }\r\n}\r\nCatch\r\n{\r\n  # Save Error Mesage\r\n  $ListViewItem.SubItems[5].Text = $Error[0].Exception.Message\r\n}\r\n\r\n\r\nFor ($I = 8; $I -lt 16; $I++)\r\n{\r\n  $ListViewItem.SubItems[$I].Text = [DateTime]::Now.ToString(\"HH:mm:ss:ffff\")\r\n  [System.Threading.Thread]::Sleep(100)\r\n}\r\n\r\n$RndValue = $Random.Next(0, 3)\r\n$ListViewItem.SubItems[6].Text = $RndValue\r\n# Random Fail Simlater\r\nIf ($RndValue -eq 0)\r\n{\r\n  $WasSuccess = $False\r\n}\r\n$ListViewItem.SubItems[7].Text = $WasSuccess\r\n\r\nIf ($WasSuccess)\r\n{\r\n  # Return Success\r\n  $ListViewItem.ImageKey = $GoodIcon\r\n  $ListViewItem.SubItems[1].Text = \"Completed\"\r\n}\r\nElse\r\n{\r\n  # Return Success\r\n  $ListViewItem.ImageKey = $BadIcon\r\n  $ListViewItem.SubItems[1].Text = \"Error\"\r\n}\r\n\r\nExit\r\n\r\n\r\n"}
