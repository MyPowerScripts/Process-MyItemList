<Objs Version="1.1.0.1" xmlns="http://schemas.microsoft.com/powershell/2004/04">
  <Obj RefId="0">
    <TN RefId="0">
      <T>PILThreadConfig</T>
      <T>System.Object</T>
    </TN>
    <ToString>PILThreadConfig</ToString>
    <Props>
      <Obj N="ColumnNames" RefId="1">
        <TN RefId="1">
          <T>System.Collections.ArrayList</T>
          <T>System.Object</T>
        </TN>
        <LST>
          <S>Column Name 00</S>
          <S>Column Name 01</S>
          <S>Column Name 02</S>
          <S>Column Name 03</S>
          <S>Column Name 04</S>
          <S>Column Name 05</S>
          <S>Column Name 06</S>
          <S>Column Name 07</S>
          <S>Column Name 08</S>
          <S>Column Name 09</S>
          <S>Column Name 10</S>
          <S>Column Name 11</S>
          <S>Column Name 12</S>
          <S>Column Name 13</S>
          <S>Column Name 14</S>
          <S>Column Name 15</S>
          <S>Column Name 16</S>
          <S>Column Name 17</S>
          <S>Column Name 18</S>
          <S>Column Name 19</S>
        </LST>
      </Obj>
      <Obj N="Modules" RefId="2">
        <TN RefId="2">
          <T>System.Collections.Specialized.OrderedDictionary</T>
          <T>System.Object</T>
        </TN>
        <DCT>
          <En>
            <S N="Key">Microsoft.Graph.Authentication</S>
            <Obj N="Value" RefId="3">
              <TN RefId="3">
                <T>PILModule</T>
                <T>System.Object</T>
              </TN>
              <ToString>PILModule</ToString>
              <Props>
                <S N="Location">All Users</S>
                <S N="Name">Microsoft.Graph.Authentication</S>
                <Version N="Version">1.9.5</Version>
              </Props>
            </Obj>
          </En>
          <En>
            <S N="Key">Az.Accounts</S>
            <Obj N="Value" RefId="4">
              <TNRef RefId="3" />
              <ToString>PILModule</ToString>
              <Props>
                <S N="Location">All Users</S>
                <S N="Name">Az.Accounts</S>
                <Version N="Version">2.7.6</Version>
              </Props>
            </Obj>
          </En>
          <En>
            <S N="Key">MSAL.PS</S>
            <Obj N="Value" RefId="5">
              <TNRef RefId="3" />
              <ToString>PILModule</ToString>
              <Props>
                <S N="Location">All Users</S>
                <S N="Name">MSAL.PS</S>
                <Version N="Version">4.37.0.0</Version>
              </Props>
            </Obj>
          </En>
        </DCT>
      </Obj>
      <Obj N="Functions" RefId="6">
        <TN RefId="4">
          <T>System.Collections.Hashtable</T>
          <T>System.Object</T>
        </TN>
        <DCT>
          <En>
            <S N="Key">Get-MyADObject</S>
            <Obj N="Value" RefId="7">
              <TN RefId="5">
                <T>PILFunction</T>
                <T>System.Object</T>
              </TN>
              <ToString>PILFunction</ToString>
              <Props>
                <S N="Name">Get-MyADObject</S>
                <S N="ScriptBlock">_x000D__x000A_  &lt;#_x000D__x000A_    .SYNOPSIS_x000D__x000A_      Searches Active Directory and returns an AD SearchResultCollection._x000D__x000A_    .DESCRIPTION_x000D__x000A_      Performs a search in Active Directory using the specified LDAP filter and returns a SearchResultCollection. _x000D__x000A_      Supports specifying search root, server, credentials, properties to load, sorting, and paging options._x000D__x000A_    .PARAMETER LDAPFilter_x000D__x000A_      The LDAP filter string to use for the search. Defaults to (objectClass=*)._x000D__x000A_    .PARAMETER PageSize_x000D__x000A_      The number of objects to return per page. Default is 1000._x000D__x000A_    .PARAMETER SizeLimit_x000D__x000A_      The maximum number of objects to return. Default is 1000._x000D__x000A_    .PARAMETER SearchRoot_x000D__x000A_      The LDAP path to start the search from. Defaults to the current domain root._x000D__x000A_    .PARAMETER ServerName_x000D__x000A_      The name of the domain controller or server to query. If not specified, uses the default._x000D__x000A_    .PARAMETER SearchScope_x000D__x000A_      The scope of the search. Valid values are Base, OneLevel, or Subtree. Default is Subtree._x000D__x000A_    .PARAMETER Sort_x000D__x000A_      The direction to sort the results. Valid values are Ascending or Descending. Default is Ascending._x000D__x000A_    .PARAMETER SortProperty_x000D__x000A_      The property name to sort the results by._x000D__x000A_    .PARAMETER PropertiesToLoad_x000D__x000A_      An array of property names to load for each result._x000D__x000A_    .PARAMETER Credential_x000D__x000A_      The credentials to use when searching Active Directory._x000D__x000A_    .EXAMPLE_x000D__x000A_      Get-MyADObject -LDAPFilter "(objectClass=user)" -SearchRoot "OU=Users,DC=domain,DC=com"_x000D__x000A_      Searches for all user objects in the specified OU._x000D__x000A_    .EXAMPLE_x000D__x000A_      Get-MyADObject -ServerName "dc01.domain.com" -PropertiesToLoad "samaccountname","mail"_x000D__x000A_      Searches using a specific domain controller and returns only the samaccountname and mail properties._x000D__x000A_    .NOTES_x000D__x000A_      Original Function By Ken Sweet_x000D__x000A_  #&gt;_x000D__x000A_  [CmdletBinding(DefaultParameterSetName = "Default")]_x000D__x000A_  param (_x000D__x000A_    [String]$LDAPFilter = "(objectClass=*)",_x000D__x000A_    [Long]$PageSize = 1000,_x000D__x000A_    [Long]$SizeLimit = 1000,_x000D__x000A_    [String]$SearchRoot = "LDAP://$($([ADSI]'').distinguishedName)",_x000D__x000A_    [String]$ServerName,_x000D__x000A_    [ValidateSet("Base", "OneLevel", "Subtree")]_x000D__x000A_    [System.DirectoryServices.SearchScope]$SearchScope = "SubTree",_x000D__x000A_    [ValidateSet("Ascending", "Descending")]_x000D__x000A_    [System.DirectoryServices.SortDirection]$Sort = "Ascending",_x000D__x000A_    [String]$SortProperty,_x000D__x000A_    [String[]]$PropertiesToLoad,_x000D__x000A_    [PSCredential]$Credential_x000D__x000A_  )_x000D__x000A_  Write-Verbose -Message "Enter Function $($MyInvocation.MyCommand)"_x000D__x000A__x000D__x000A_  $MySearcher = [System.DirectoryServices.DirectorySearcher]::New($LDAPFilter, $PropertiesToLoad, $SearchScope)_x000D__x000A__x000D__x000A_  $MySearcher.PageSize = $PageSize_x000D__x000A_  $MySearcher.SizeLimit = $SizeLimit_x000D__x000A__x000D__x000A_  $TempSearchRoot = $SearchRoot.ToUpper()_x000D__x000A_  switch -regex ($TempSearchRoot)_x000D__x000A_  {_x000D__x000A_    "(?:LDAP|GC)://*"_x000D__x000A_    {_x000D__x000A_      if ($PSBoundParameters.ContainsKey("ServerName"))_x000D__x000A_      {_x000D__x000A_        $MySearchRoot = $TempSearchRoot -replace "(?&lt;LG&gt;(?:LDAP|GC)://)(?:[\w\d\.-]+/)?(?&lt;DN&gt;.+)", "`${LG}$($ServerName)/`${DN}"_x000D__x000A_      }_x000D__x000A_      else_x000D__x000A_      {_x000D__x000A_        $MySearchRoot = $TempSearchRoot_x000D__x000A_      }_x000D__x000A_      break_x000D__x000A_    }_x000D__x000A_    default_x000D__x000A_    {_x000D__x000A_      if ($PSBoundParameters.ContainsKey("ServerName"))_x000D__x000A_      {_x000D__x000A_        $MySearchRoot = "LDAP://$($ServerName)/$($TempSearchRoot)"_x000D__x000A_      }_x000D__x000A_      else_x000D__x000A_      {_x000D__x000A_        $MySearchRoot = "LDAP://$($TempSearchRoot)"_x000D__x000A_      }_x000D__x000A_      break_x000D__x000A_    }_x000D__x000A_  }_x000D__x000A__x000D__x000A_  if ($PSBoundParameters.ContainsKey("Credential"))_x000D__x000A_  {_x000D__x000A_    $MySearcher.SearchRoot = [System.DirectoryServices.DirectoryEntry]::New($MySearchRoot, ($Credential.UserName), (($Credential.GetNetworkCredential()).Password))_x000D__x000A_  }_x000D__x000A_  else_x000D__x000A_  {_x000D__x000A_    $MySearcher.SearchRoot = [System.DirectoryServices.DirectoryEntry]::New($MySearchRoot)_x000D__x000A_  }_x000D__x000A__x000D__x000A_  if ($PSBoundParameters.ContainsKey("SortProperty"))_x000D__x000A_  {_x000D__x000A_    $MySearcher.Sort.PropertyName = $SortProperty_x000D__x000A_    $MySearcher.Sort.Direction = $Sort_x000D__x000A_  }_x000D__x000A__x000D__x000A_  $MySearcher.FindAll()_x000D__x000A__x000D__x000A_  $MySearcher.Dispose()_x000D__x000A_  $MySearcher = $Null_x000D__x000A_  $MySearchRoot = $Null_x000D__x000A_  $TempSearchRoot = $Null_x000D__x000A__x000D__x000A_  Write-Verbose -Message "Exit Function $($MyInvocation.MyCommand)"_x000D__x000A_</S>
              </Props>
            </Obj>
          </En>
          <En>
            <S N="Key">Get-MyADForest</S>
            <Obj N="Value" RefId="8">
              <TNRef RefId="5" />
              <ToString>PILFunction</ToString>
              <Props>
                <S N="Name">Get-MyADForest</S>
                <S N="ScriptBlock">_x000D__x000A_  &lt;#_x000D__x000A_    .SYNOPSIS_x000D__x000A_      Gets information about an Active Directory Forest._x000D__x000A_    .DESCRIPTION_x000D__x000A_      Retrieves the Active Directory Forest object either for the current forest or for a specified forest name._x000D__x000A_    .PARAMETER Name_x000D__x000A_      The name of the Active Directory forest to retrieve. This parameter is mandatory when using the "Name" parameter set._x000D__x000A_    .PARAMETER Current_x000D__x000A_      Switch parameter. If specified, retrieves the current Active Directory forest. This parameter is mandatory when using the "Current" parameter set._x000D__x000A_    .EXAMPLE_x000D__x000A_      PS C:\&gt; Get-MyADForest -Current_x000D__x000A_      Retrieves the current Active Directory forest._x000D__x000A_    .EXAMPLE_x000D__x000A_      PS C:\&gt; Get-MyADForest -Name "contoso.com"_x000D__x000A_      Retrieves the Active Directory forest with the name "contoso.com"._x000D__x000A_    .NOTES_x000D__x000A_      Original Function By Ken Sweet_x000D__x000A_  #&gt;_x000D__x000A_  [CmdletBinding(DefaultParameterSetName = "Current")]_x000D__x000A_  param (_x000D__x000A_    [parameter(Mandatory = $True, ParameterSetName = "Name")]_x000D__x000A_    [String]$Name,_x000D__x000A_    [parameter(Mandatory = $True, ParameterSetName = "Current")]_x000D__x000A_    [Switch]$Current_x000D__x000A_  )_x000D__x000A_  Write-Verbose -Message "Enter Function $($MyInvocation.MyCommand)"_x000D__x000A__x000D__x000A_  switch ($PSCmdlet.ParameterSetName)_x000D__x000A_  {_x000D__x000A_    "Name"_x000D__x000A_    {_x000D__x000A_      $DirectoryContextType = [System.DirectoryServices.ActiveDirectory.DirectoryContextType]::Forest_x000D__x000A_      $DirectoryContext = [System.DirectoryServices.ActiveDirectory.DirectoryContext]::New($DirectoryContextType, $Name)_x000D__x000A_      [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($DirectoryContext)_x000D__x000A_      $DirectoryContext = $Null_x000D__x000A_      $DirectoryContextType = $Null_x000D__x000A_      break_x000D__x000A_    }_x000D__x000A_    "Current"_x000D__x000A_    {_x000D__x000A_      [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()_x000D__x000A_      break_x000D__x000A_    }_x000D__x000A_  }_x000D__x000A__x000D__x000A_  Write-Verbose -Message "Exit Function $($MyInvocation.MyCommand)"_x000D__x000A_</S>
              </Props>
            </Obj>
          </En>
          <En>
            <S N="Key">Get-MyWorkstationInfo</S>
            <Obj N="Value" RefId="9">
              <TNRef RefId="5" />
              <ToString>PILFunction</ToString>
              <Props>
                <S N="Name">Get-MyWorkstationInfo</S>
                <S N="ScriptBlock">_x000D__x000A_  &lt;#_x000D__x000A_    .SYNOPSIS_x000D__x000A_      Verify Remote Workstation is the Correct One_x000D__x000A_    .DESCRIPTION_x000D__x000A_      Verify Remote Workstation is the Correct One_x000D__x000A_    .PARAMETER ComputerName_x000D__x000A_      Name of the Computer to Verify_x000D__x000A_    .PARAMETER Credential_x000D__x000A_      Credentials to use when connecting to the Remote Computer_x000D__x000A_    .PARAMETER Serial_x000D__x000A_      Return Serial Number_x000D__x000A_    .PARAMETER Mobile_x000D__x000A_      Check if System is Desktop / Laptop_x000D__x000A_    .INPUTS_x000D__x000A_    .OUTPUTS_x000D__x000A_    .EXAMPLE_x000D__x000A_      Get-MyWorkstationInfo -ComputerName "MyWorkstation"_x000D__x000A_    .NOTES_x000D__x000A_      Original Script By Ken Sweet_x000D__x000A_    .LINK_x000D__x000A_  #&gt;_x000D__x000A_  [CmdletBinding()]_x000D__x000A_  param (_x000D__x000A_    [parameter(Mandatory = $False, ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]_x000D__x000A_    [String[]]$ComputerName = [System.Environment]::MachineName,_x000D__x000A_    [PSCredential]$Credential,_x000D__x000A_    [Switch]$Serial,_x000D__x000A_    [Switch]$Mobile_x000D__x000A_  )_x000D__x000A_  begin_x000D__x000A_  {_x000D__x000A_    Write-Verbose -Message "Enter Function Get-MyWorkstationInfo"_x000D__x000A__x000D__x000A_    # Default Common Get-WmiObject Options_x000D__x000A_    if ($PSBoundParameters.ContainsKey("Credential"))_x000D__x000A_    {_x000D__x000A_      $Params = @{_x000D__x000A_        "ComputerName" = $Null_x000D__x000A_        "Credential"   = $Credential_x000D__x000A_      }_x000D__x000A_    }_x000D__x000A_    else_x000D__x000A_    {_x000D__x000A_      $Params = @{_x000D__x000A_        "ComputerName" = $Null_x000D__x000A_      }_x000D__x000A_    }_x000D__x000A_  }_x000D__x000A_  process_x000D__x000A_  {_x000D__x000A_    Write-Verbose -Message "Enter Function Get-MyWorkstationInfo - Process"_x000D__x000A__x000D__x000A_    foreach ($Computer in $ComputerName)_x000D__x000A_    {_x000D__x000A_      # Start Setting Return Values as they are Found_x000D__x000A_      $VerifyObject = [MyWorkstationInfo]::New($Computer)_x000D__x000A__x000D__x000A_      # Validate ComputerName_x000D__x000A_      if ($Computer -match "^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$")_x000D__x000A_      {_x000D__x000A_        try_x000D__x000A_        {_x000D__x000A_          # Get IP Address from DNS, you want to do all remote checks using IP rather than ComputerName.  If you connect to a computer using the wrong name Get-WmiObject will fail and using the IP Address will not_x000D__x000A_          $IPAddresses = @([System.Net.Dns]::GetHostAddresses($Computer) | Where-Object -FilterScript { $_.AddressFamily -eq [System.Net.Sockets.AddressFamily]::InterNetwork } | Select-Object -ExpandProperty IPAddressToString)_x000D__x000A_          :FoundMyWork foreach ($IPAddress in $IPAddresses)_x000D__x000A_          {_x000D__x000A_            if ([System.Net.NetworkInformation.Ping]::New().Send($IPAddress).Status -eq [System.Net.NetworkInformation.IPStatus]::Success)_x000D__x000A_            {_x000D__x000A_              # Set Default Parms_x000D__x000A_              $Params.ComputerName = $IPAddress_x000D__x000A__x000D__x000A_              # Get ComputerSystem_x000D__x000A_              [Void]($MyCompData = Get-WmiObject @Params -Class Win32_ComputerSystem)_x000D__x000A_              $VerifyObject.AddComputerSystem($Computer, $IPAddress, ($MyCompData.Name), ($MyCompData.PartOfDomain), ($MyCompData.Domain), ($MyCompData.Manufacturer), ($MyCompData.Model), ($MyCompData.UserName), ($MyCompData.TotalPhysicalMemory))_x000D__x000A_              $MyCompData.Dispose()_x000D__x000A__x000D__x000A_              # Verify Remote Computer is the Connect Computer, No need to get any more information_x000D__x000A_              if ($VerifyObject.Found)_x000D__x000A_              {_x000D__x000A_                # Start Secondary Job, Pass IP Address and Credentials to Job Script to make Connection to Remote Computer_x000D__x000A_                [Void]($MyOSData = Get-WmiObject @Params -Class Win32_OperatingSystem)_x000D__x000A_                $VerifyObject.AddOperatingSystem(($MyOSData.ProductType), ($MyOSData.Caption), ($MyOSData.CSDVersion), ($MyOSData.BuildNumber), ($MyOSData.Version), ($MyOSData.OSArchitecture), ([System.Management.ManagementDateTimeConverter]::ToDateTime($MyOSData.LocalDateTime)), ([System.Management.ManagementDateTimeConverter]::ToDateTime($MyOSData.InstallDate)), ([System.Management.ManagementDateTimeConverter]::ToDateTime($MyOSData.LastBootUpTime)))_x000D__x000A_                $MyOSData.Dispose()_x000D__x000A__x000D__x000A_                # Optional SerialNumber Job_x000D__x000A_                if ($Serial.IsPresent)_x000D__x000A_                {_x000D__x000A_                  # Start Optional Job, Pass IP Address and Credentials to Job Script to make Connection to Remote Computer_x000D__x000A_                  [Void]($MyBIOSData = Get-WmiObject @Params -Class Win32_Bios)_x000D__x000A_                  $VerifyObject.AddSerialNumber($MyBIOSData.SerialNumber)_x000D__x000A_                  $MyBIOSData.Dispose()_x000D__x000A_                }_x000D__x000A__x000D__x000A_                # Optional Mobile / ChassisType Job_x000D__x000A_                if ($Mobile.IsPresent)_x000D__x000A_                {_x000D__x000A_                  # Start Optional Job, Pass IP Address and Credentials to Job Script to make Connection to Remote Computer_x000D__x000A_                  [Void]($MyChassisData = Get-WmiObject @Params -Class Win32_SystemEnclosure)_x000D__x000A_                  $VerifyObject.AddIsMobile($MyChassisData.ChassisTypes)_x000D__x000A_                  $MyChassisData.Dispose()_x000D__x000A_                }_x000D__x000A_              }_x000D__x000A_              else_x000D__x000A_              {_x000D__x000A_                $VerifyObject.UpdateStatus("Wrong Workstation Name")_x000D__x000A_              }_x000D__x000A_              # Beak out of Loop, Verify was a Success no need to try other IP Address if any_x000D__x000A_              break FoundMyWork_x000D__x000A_            }_x000D__x000A_          }_x000D__x000A_        }_x000D__x000A_        catch_x000D__x000A_        {_x000D__x000A_          # Workstation Not in DNS_x000D__x000A_          $VerifyObject.UpdateStatus("Workstation Not in DNS")_x000D__x000A_        }_x000D__x000A_      }_x000D__x000A_      else_x000D__x000A_      {_x000D__x000A_        $VerifyObject.UpdateStatus("Invalid Computer Name")_x000D__x000A_      }_x000D__x000A__x000D__x000A_      # Set End Time and Return Results_x000D__x000A_      $VerifyObject.SetEndTime()_x000D__x000A_    }_x000D__x000A_    Write-Verbose -Message "Exit Function Get-MyWorkstationInfo - Process"_x000D__x000A_  }_x000D__x000A_  end_x000D__x000A_  {_x000D__x000A_    [System.GC]::Collect()_x000D__x000A_    [System.GC]::WaitForPendingFinalizers()_x000D__x000A_    Write-Verbose -Message "Exit Function Get-MyWorkstationInfo"_x000D__x000A_  }_x000D__x000A_</S>
              </Props>
            </Obj>
          </En>
        </DCT>
      </Obj>
      <Obj N="Variables" RefId="10">
        <TNRef RefId="4" />
        <DCT>
          <En>
            <S N="Key">Z</S>
            <Obj N="Value" RefId="11">
              <TN RefId="6">
                <T>PILVariable</T>
                <T>System.Object</T>
              </TN>
              <ToString>PILVariable</ToString>
              <Props>
                <S N="Name">Z</S>
                <S N="Value">Z</S>
              </Props>
            </Obj>
          </En>
          <En>
            <S N="Key">X</S>
            <Obj N="Value" RefId="12">
              <TNRef RefId="6" />
              <ToString>PILVariable</ToString>
              <Props>
                <S N="Name">X</S>
                <S N="Value">X</S>
              </Props>
            </Obj>
          </En>
          <En>
            <S N="Key">Y</S>
            <Obj N="Value" RefId="13">
              <TNRef RefId="6" />
              <ToString>PILVariable</ToString>
              <Props>
                <S N="Name">Y</S>
                <S N="Value">Y</S>
              </Props>
            </Obj>
          </En>
        </DCT>
      </Obj>
      <U16 N="ThreadCount">8</U16>
      <S N="ThreadScript">&lt;#_x000D__x000A_  .SYNOPSIS_x000D__x000A_    Sample Runspace Pool Thread Script_x000D__x000A_  .DESCRIPTION_x000D__x000A_    Sample Runspace Pool Thread Script_x000D__x000A_  .PARAMETER ListViewItem_x000D__x000A_    ListViewItem Passed to the Thread Script_x000D__x000A__x000D__x000A_    This Paramter is Required in your Thread Script_x000D__x000A_  .EXAMPLE_x000D__x000A_    Test-Script.ps1 -ListViewItem $ListViewItem_x000D__x000A_  .NOTES_x000D__x000A_    Sample Thread Script_x000D__x000A_#&gt;_x000D__x000A_[CmdletBinding(DefaultParameterSetName = "ByValue")]_x000D__x000A_Param (_x000D__x000A_  [parameter(Mandatory = $False, ParameterSetName = "ByValue")]_x000D__x000A_  [System.Windows.Forms.ListViewItem]$ListViewItem_x000D__x000A_)_x000D__x000A__x000D__x000A_# Set Preference Variables_x000D__x000A_$ErrorActionPreference = "Stop"_x000D__x000A_$VerbosePreference = "SilentlyContinue"_x000D__x000A_$ProgressPreference = "SilentlyContinue"_x000D__x000A__x000D__x000A_# -------------------------_x000D__x000A_# ListViewItem Status Icons_x000D__x000A_# -------------------------_x000D__x000A_# $GoodIcon = Solid Green Circle_x000D__x000A_# $BadIcon = Solid Red Circle_x000D__x000A_# $InfoIcon = Solid Blue Circle_x000D__x000A_# $CheckIcon = Checkmark_x000D__x000A_# $ErrorIcon = Red X_x000D__x000A_# $UpIcon = Green up Arrow _x000D__x000A_# $DownIcon = Red Down Arrow_x000D__x000A__x000D__x000A_# ------------------------------------------------_x000D__x000A_# Check if Thread was Already Completed and Exit_x000D__x000A_#_x000D__x000A_# One Column needs to be the Status the the Thread_x000D__x000A_#  Status Messages are Customizable_x000D__x000A_# ------------------------------------------------_x000D__x000A_If ($ListViewItem.SubItems[1].Text -eq "Completed")_x000D__x000A_{_x000D__x000A_  $ListViewItem.ImageKey = $GoodIcon_x000D__x000A_  Exit_x000D__x000A_}_x000D__x000A__x000D__x000A_# ----------------------------------------------------_x000D__x000A_# Check if Threads are Paused and Update Thread Status_x000D__x000A_#_x000D__x000A_# You can add Multiple Checks for Pasue if Needed_x000D__x000A_# ----------------------------------------------------_x000D__x000A_If ($SyncedHash.Paused)_x000D__x000A_{_x000D__x000A_  # Set Paused Status_x000D__x000A_  $ListViewItem.SubItems[1].Text = "Pause"_x000D__x000A_  While ($SyncedHash.Paused)_x000D__x000A_  {_x000D__x000A_    [System.Threading.Thread]::Sleep(100)_x000D__x000A_  }_x000D__x000A_}_x000D__x000A__x000D__x000A_# -----------------------------------------------------_x000D__x000A_# Check For Termination and Update Thread Status_x000D__x000A_#_x000D__x000A_# You can add Multiple Checks for Termination if Needed_x000D__x000A_# -----------------------------------------------------_x000D__x000A_If ($SyncedHash.Terminate)_x000D__x000A_{_x000D__x000A_  # Set Terminated Status and Return_x000D__x000A_  $ListViewItem.SubItems[1].Text = "Terminated"_x000D__x000A_  $ListViewItem.SubItems[2].Text = [DateTime]::Now.ToString("g")_x000D__x000A_  $ListViewItem.ImageKey = $InfoIcon_x000D__x000A_  Exit_x000D__x000A_}_x000D__x000A__x000D__x000A_# Set Proccessing Ststus_x000D__x000A_$ListViewItem.SubItems[1].Text = "Processing"_x000D__x000A_$ListViewItem.SubItems[2].Text = [DateTime]::Now.ToString("g")_x000D__x000A_$WasSuccess = $True_x000D__x000A__x000D__x000A_# --------------------------------------------------_x000D__x000A_# Get Curent List Item_x000D__x000A_#_x000D__x000A_# Coulmn 0 Always has the List Item to be Proccessed_x000D__x000A_# --------------------------------------------------_x000D__x000A_$CurentItem = $ListViewItem.SubItems[0].Text_x000D__x000A__x000D__x000A_# --------------------------------------------------------------_x000D__x000A_# Open and wait for Mutex_x000D__x000A_# _x000D__x000A_# This is to Pause the Thread Script if Access a Shared Resource_x000D__x000A_#   and you need toi Limit to 1 Thread at a Time_x000D__x000A_#_x000D__x000A_# Using a Mutext is Optional_x000D__x000A_# --------------------------------------------------------------_x000D__x000A_$MyMutex = [System.Threading.Mutex]::OpenExisting($Mutex)_x000D__x000A_[Void]($MyMutex.WaitOne())_x000D__x000A__x000D__x000A_# Set Date / Time when Mutext was Opened_x000D__x000A_$ListViewItem.SubItems[3].Text = [DateTime]::Now.ToString("g")_x000D__x000A__x000D__x000A_# --------------------------------------------------------------------------------_x000D__x000A_# The Synced HashTable has an Object Property to share information between Threads_x000D__x000A_# --------------------------------------------------------------------------------_x000D__x000A_If ([String]::IsNullOrEmpty($SyncedHash.Object))_x000D__x000A_{_x000D__x000A_  $SyncedHash.Object = "First"_x000D__x000A_}_x000D__x000A_$ListViewItem.SubItems[4].Text = $SyncedHash.Object_x000D__x000A_$SyncedHash.Object = $CurentItem_x000D__x000A__x000D__x000A_# Release Mutex_x000D__x000A_$MyMutex.ReleaseMutex()_x000D__x000A__x000D__x000A_# Random Number Generator_x000D__x000A_$Random = [System.Random]::New()_x000D__x000A__x000D__x000A_# ---------------------------------------------------------_x000D__x000A_# Gernate a Fake Error_x000D__x000A_#_x000D__x000A_# Make sure to use Error Catching to make sure thread exits_x000D__x000A_# ---------------------------------------------------------_x000D__x000A_Try_x000D__x000A_{_x000D__x000A_  Switch ($Random.Next(0, 3))_x000D__x000A_  {_x000D__x000A_    "0"_x000D__x000A_    {_x000D__x000A_      Throw "This is a Fake Error!"_x000D__x000A_      Break_x000D__x000A_    }_x000D__x000A_    "1"_x000D__x000A_    {_x000D__x000A_      Throw "Simulated Error!"_x000D__x000A_      Break_x000D__x000A_    }_x000D__x000A_    "2"_x000D__x000A_    {_x000D__x000A_      Throw "Someing Failed!"_x000D__x000A_      Break_x000D__x000A_    }_x000D__x000A_    "3"_x000D__x000A_    {_x000D__x000A_      Throw "Unknown Error!"_x000D__x000A_      Break_x000D__x000A_    }_x000D__x000A_  }_x000D__x000A_}_x000D__x000A_Catch_x000D__x000A_{_x000D__x000A_  # Save Error Mesage_x000D__x000A_  $ListViewItem.SubItems[5].Text = $Error[0].Exception.Message_x000D__x000A_}_x000D__x000A__x000D__x000A__x000D__x000A_For ($I = 8; $I -lt 16; $I++)_x000D__x000A_{_x000D__x000A_  $ListViewItem.SubItems[$I].Text = [DateTime]::Now.ToString("HH:mm:ss:ffff")_x000D__x000A_  [System.Threading.Thread]::Sleep(100)_x000D__x000A_}_x000D__x000A__x000D__x000A_$RndValue = $Random.Next(0, 3)_x000D__x000A_$ListViewItem.SubItems[6].Text = $RndValue_x000D__x000A_# Random Fail Simlater_x000D__x000A_If ($RndValue -eq 0)_x000D__x000A_{_x000D__x000A_  $WasSuccess = $False_x000D__x000A_}_x000D__x000A_$ListViewItem.SubItems[7].Text = $WasSuccess_x000D__x000A__x000D__x000A_If ($WasSuccess)_x000D__x000A_{_x000D__x000A_  # Return Success_x000D__x000A_  $ListViewItem.ImageKey = $GoodIcon_x000D__x000A_  $ListViewItem.SubItems[1].Text = "Completed"_x000D__x000A_}_x000D__x000A_Else_x000D__x000A_{_x000D__x000A_  # Return Success_x000D__x000A_  $ListViewItem.ImageKey = $BadIcon_x000D__x000A_  $ListViewItem.SubItems[1].Text = "Error"_x000D__x000A_}_x000D__x000A__x000D__x000A_Exit_x000D__x000A__x000D__x000A__x000D__x000A_</S>
    </Props>
  </Obj>
</Objs>